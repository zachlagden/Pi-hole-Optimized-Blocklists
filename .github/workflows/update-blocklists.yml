name: Update Blocklists

on:
  schedule:
    - cron: '0 0 * * 0'  # Run weekly on Sunday at midnight UTC
  workflow_dispatch:  # Allow manual triggering

jobs:
  update-blocklists:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          lfs: true
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0  # Fetch all history to properly work with LFS
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests tqdm
          echo "Installed Python dependencies"
          
      - name: Clone Optimizer repository
        run: |
          git clone https://github.com/zachlagden/Pi-hole-Blocklist-Optimizer.git optimizer
          echo "Cloned Pi-hole-Blocklist-Optimizer repository"
          
      - name: Run Optimizer
        run: |
          cp blocklists.conf optimizer/
          cd optimizer
          echo "Running Pi-hole Blocklist Optimizer..."
          python pihole_downloader.py --prod-dir pihole_blocklists_prod
          
          # Check if the optimizer produced the expected files
          if [ ! -f "pihole_blocklists_prod/all_domains.txt" ]; then
            echo "Error: Optimizer did not produce all_domains.txt file"
            exit 1
          fi
          echo "Optimizer completed successfully"
          
      - name: Extract statistics from optimizer output
        id: stats
        run: |
          echo "Files in optimizer/pihole_blocklists_prod:"
          ls -la optimizer/pihole_blocklists_prod/
          
          # Extract statistics from the optimizer's output
          TOTAL_DOMAINS=$(grep "unique_domains" optimizer/pihole_blocklists_prod/_production_stats.json | grep -o '[0-9]*' | head -1)
          DUPLICATES=$(grep "duplicate_domains" optimizer/pihole_blocklists/blocklist_stats.json | grep -o '[0-9]*' | head -1)
          SOURCE_LISTS=$(grep "total_lists" optimizer/pihole_blocklists/blocklist_stats.json | grep -o '[0-9]*' | head -1)
          CATEGORIES=$(ls optimizer/pihole_blocklists_prod/ | grep -v "_" | grep "\.txt$" | wc -l)
          ELAPSED_TIME=$(grep "elapsed_time" optimizer/pihole_blocklists/blocklist_stats.json | grep -o '[0-9.]*' | head -1)
          
          # Extract individual list statistics
          AD_DOMAINS=$(grep -A 1 "advertising" optimizer/pihole_blocklists_prod/_production_stats.json | grep "domains" | grep -o '[0-9]*' | head -1)
          TRACKING_DOMAINS=$(grep -A 1 "tracking" optimizer/pihole_blocklists_prod/_production_stats.json | grep "domains" | grep -o '[0-9]*' | head -1)
          MALICIOUS_DOMAINS=$(grep -A 1 "malicious" optimizer/pihole_blocklists_prod/_production_stats.json | grep "domains" | grep -o '[0-9]*' | head -1)
          SUSPICIOUS_DOMAINS=$(grep -A 1 "suspicious" optimizer/pihole_blocklists_prod/_production_stats.json | grep "domains" | grep -o '[0-9]*' | head -1)
          COMPREHENSIVE_DOMAINS=$(grep -A 1 "comprehensive" optimizer/pihole_blocklists_prod/_production_stats.json | grep "domains" | grep -o '[0-9]*' | head -1)
          NSFW_DOMAINS=$(grep -A 1 "nsfw" optimizer/pihole_blocklists_prod/_production_stats.json | grep "domains" | grep -o '[0-9]*' | head -1)
          
          # Create formatted output for GitHub Actions
          echo "total_domains=$TOTAL_DOMAINS" >> $GITHUB_OUTPUT
          echo "duplicates=$DUPLICATES" >> $GITHUB_OUTPUT
          echo "source_lists=$SOURCE_LISTS" >> $GITHUB_OUTPUT
          echo "categories=$CATEGORIES" >> $GITHUB_OUTPUT
          echo "elapsed_time=$ELAPSED_TIME" >> $GITHUB_OUTPUT
          echo "ad_domains=$AD_DOMAINS" >> $GITHUB_OUTPUT
          echo "tracking_domains=$TRACKING_DOMAINS" >> $GITHUB_OUTPUT
          echo "malicious_domains=$MALICIOUS_DOMAINS" >> $GITHUB_OUTPUT
          echo "suspicious_domains=$SUSPICIOUS_DOMAINS" >> $GITHUB_OUTPUT
          echo "comprehensive_domains=$COMPREHENSIVE_DOMAINS" >> $GITHUB_OUTPUT
          echo "nsfw_domains=$NSFW_DOMAINS" >> $GITHUB_OUTPUT
          echo "update_date=$(date +%B\ %d,\ %Y)" >> $GITHUB_OUTPUT
          
      - name: Update README with latest statistics
        run: |
          # Create a temporary file
          cp README.md README.md.tmp
          
          # Update statistics section
          sed -i 's/\*\*[0-9.,]\+ million\*\* unique domains/**${{ steps.stats.outputs.total_domains }}** unique domains/g' README.md.tmp
          sed -i 's/\*\*[0-9]\+\*\* source blocklists/**${{ steps.stats.outputs.source_lists }}** source blocklists/g' README.md.tmp
          sed -i 's/\*\*[0-9]\+\*\* categories/**${{ steps.stats.outputs.categories }}** categories/g' README.md.tmp
          sed -i 's/\*\*~[0-9]\+K\*\* duplicate domains/**~${{ steps.stats.outputs.duplicates }}** duplicate domains/g' README.md.tmp
          sed -i 's/\*\*Last updated\*\*: .*/**Last updated**: ${{ steps.stats.outputs.update_date }}/g' README.md.tmp
          
          # Update list information in the table
          sed -i 's/| \*\*all_domains.txt\*\* | Complete collection of all unique domains | [0-9,]\+ |/| **all_domains.txt** | Complete collection of all unique domains | ${{ steps.stats.outputs.total_domains }} |/g' README.md.tmp
          sed -i 's/| \*\*advertising.txt\*\* | Ad networks and services | [0-9,]\+ |/| **advertising.txt** | Ad networks and services | ${{ steps.stats.outputs.ad_domains }} |/g' README.md.tmp
          sed -i 's/| \*\*tracking.txt\*\* | Analytics and tracking services | [0-9,]\+ |/| **tracking.txt** | Analytics and tracking services | ${{ steps.stats.outputs.tracking_domains }} |/g' README.md.tmp
          sed -i 's/| \*\*malicious.txt\*\* | Malware, phishing, and scams | [0-9,]\+ |/| **malicious.txt** | Malware, phishing, and scams | ${{ steps.stats.outputs.malicious_domains }} |/g' README.md.tmp
          sed -i 's/| \*\*suspicious.txt\*\* | Potentially unwanted content | [0-9,]\+ |/| **suspicious.txt** | Potentially unwanted content | ${{ steps.stats.outputs.suspicious_domains }} |/g' README.md.tmp
          sed -i 's/| \*\*comprehensive.txt\*\* | Well-maintained multi-category lists | [0-9,]\+ |/| **comprehensive.txt** | Well-maintained multi-category lists | ${{ steps.stats.outputs.comprehensive_domains }} |/g' README.md.tmp
          sed -i 's/| \*\*nsfw.txt\*\* | Adult content | [0-9,]\+ |/| **nsfw.txt** | Adult content | ${{ steps.stats.outputs.nsfw_domains }} |/g' README.md.tmp
          
          # Update just the Latest Update section (assuming it exists)
          sed -i '/### Latest Update/{n;n;n;n;n;s/- \*\*Date\*\*: .*/- **Date**: ${{ steps.stats.outputs.update_date }}/;}' README.md.tmp
          sed -i '/### Latest Update/{n;n;n;n;s/- \*\*Processing time\*\*: .*/- **Processing time**: ${{ steps.stats.outputs.elapsed_time }} seconds/;}' README.md.tmp
          sed -i '/### Latest Update/{n;n;n;s/- \*\*Total domains\*\*: .*/- **Total domains**: ${{ steps.stats.outputs.total_domains }}/;}' README.md.tmp
          sed -i '/### Latest Update/{n;n;s/- \*\*Duplicates removed\*\*: .*/- **Duplicates removed**: ${{ steps.stats.outputs.duplicates }}/;}' README.md.tmp
          
          # Move the updated file back
          mv README.md.tmp README.md
          
      - name: Check for changes in blocklists
        id: check_changes
        run: |
          # Ensure lists directory exists
          mkdir -p lists
          
          # Define the files to check - ONLY the category files
          FILES=("all_domains.txt" "advertising.txt" "tracking.txt" "malicious.txt" "suspicious.txt" "comprehensive.txt" "nsfw.txt")
          
          # Track if any files have changed
          CHANGES_DETECTED=false
          CHANGED_FILES=""
          
          # Compare each file if it exists
          for file in "${FILES[@]}"; do
            if [ -f "optimizer/pihole_blocklists_prod/$file" ]; then
              if [ -f "lists/$file" ]; then
                # Use cmp to compare binary files
                if ! cmp -s "optimizer/pihole_blocklists_prod/$file" "lists/$file"; then
                  echo "Changes detected in $file"
                  CHANGES_DETECTED=true
                  CHANGED_FILES="$CHANGED_FILES $file"
                  cp "optimizer/pihole_blocklists_prod/$file" "lists/$file"
                else
                  echo "No changes in $file"
                fi
              else
                echo "New file: $file"
                CHANGES_DETECTED=true
                CHANGED_FILES="$CHANGED_FILES $file"
                cp "optimizer/pihole_blocklists_prod/$file" "lists/$file"
              fi
            else
              echo "Warning: $file not found in optimizer output"
            fi
          done
          
          # Set outputs for later steps
          echo "changes_detected=$CHANGES_DETECTED" >> $GITHUB_OUTPUT
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT
          
          if [ "$CHANGES_DETECTED" = true ]; then
            echo "Changes detected in blocklists. Will update repository."
          else
            echo "No changes detected in any blocklists. Repository will remain unchanged."
          fi
          
      - name: Commit and push changes
        if: steps.check_changes.outputs.changes_detected == 'true'
        run: |
          # Add the updated blocklist files and README
          git add lists/*.txt README.md
          
          # Create detailed commit message with stats
          COMMIT_MSG="Weekly update of blocklists $(date +%F)"
          COMMIT_MSG="$COMMIT_MSG\n\n"
          COMMIT_MSG="$COMMIT_MSG- Total domains: ${{ steps.stats.outputs.total_domains }}\n"
          COMMIT_MSG="$COMMIT_MSG- Processing time: ${{ steps.stats.outputs.elapsed_time }} seconds\n"
          
          if [ ! -z "${{ steps.check_changes.outputs.changed_files }}" ]; then
            COMMIT_MSG="$COMMIT_MSG- Updated:${{ steps.check_changes.outputs.changed_files }}\n"
          fi
          
          # Double-check if there are changes to commit (safety check)
          if git diff --staged --quiet; then
            echo "No changes to commit (final verification)"
          else
            echo "Committing changes with message:"
            echo -e "$COMMIT_MSG"
            git commit -m "$COMMIT_MSG"
            
            echo "Pushing changes with LFS..."
            git push
            echo "Push completed successfully"
          fi
          
      - name: No changes report
        if: steps.check_changes.outputs.changes_detected != 'true'
        run: |
          echo "No changes detected in any blocklist files."
          echo "Repository remains unchanged. Workflow completed successfully."